动态规划（Dynamic programming），简称DP。

动态规划的核心思想就是**将问题划分为若干个子问题，并在计算子问题的基础上，逐步构建出原问题的解。**

## 动态规划的四个步骤

1. 定义状态

- 将原问题划分为若干个子问题，定义状态表示子问题的解，通常使用一个数组或者矩阵来表示。

1. 确定状态转移方程

- 在计算子问题的基础上，逐步构建出原问题的解。这个过程通常使用“状态转移”方程来描述，表示从一个状态转移到另一个状态时的规则。

1. 初始化状态
2. 计算原问题的解

- 通过计算状态之间的转移，最终计算出原问题的解。通常使用递归或者迭代的方式计算。



## 如何开始动态规划

从一个最简单的算法斐波那契数列开始入手。斐波那契数列定义如下：

- 第 0 个和第 1 个斐波那契数分别为0和1，即 F0 = 0, F1 = 1。 
- 从第 2 个数开始，每个斐波那契数都是它前面两个斐波那契数之和，即 F2 = F0 + F1，F3 = F1 + F2，F4 = F2 + F3，以此类推...

斐波那契数列可以有多重求解方法。依次来看一下。

### 递归求解

在求解斐波那契数值的时候第一个可能想到的是递归求解

```typescript
function fib(n: number): number {
  if (n <= 1) return n
  return fib(n - 1) + fib(n - 2)
}
console.log(fib(10))
```

### 记忆化搜索

对于递归算法，很容易出现重复计算的问题，因为在计算同一个子问题时，可能会被重复地计算多次。比如求f10，要求解f9 + f8，求解f9要求解f8+f7，求解f8又要求f7+f6...

为了避免这个问题，可以使用记忆化搜索的技巧，将已经计算过的结果保存下来，便于后续计算中直接使用从而提高计算效率：

```typescript
function fib(n: number, memo: number[]): number {
  if (n <= 1) {
    return n
  }
  if (memo[n]) {
    return memo[n]
  }

  const res = fib(n-1, memo) + fib(n-2, memo)
  memo[n] = res
  return res
}
console.log(fib(10, []))
```

### 动态规划

可以发现，通过记忆化搜索的方式可以避免重复计算，提高效率。**而动态规划算法就是一种利用历史状态信息来避免重复计算的算法。**

动态规划算法可以看作是记忆化搜索的一种扩展，通常采用自底向上的方式来计算子问题的结果，并将结果保存下来以便后续的计算使用。

1. **定义状态** 可以使用一个数组来保存斐波那契数列中每一个位置对应的值（`const dp: number[] = []`）
2. **确定状态转移方程** 对于斐波那契数列来说，fn = fn-1 + fn-2，所以可以确定好动态转移方程为：`dp[n] = dp[n-1] + dp[n-2]`
3. **初始化状态** 对于斐波那契数列来说，f0 = 0 f1= 1所以初始化状态可以写为 （`dp[0] = 0 dp[1] = 1`）
4. **计算原问题的解** 要求第n位的数值，可以使用迭代的方式来逐步计算

```typescript
function fib(n: number): number {
  // 定义状态
  const dp: number[] = []

  // 初始化状态
  dp[0] = 0
  dp[1] = 1

  // 求解
  for(let i = 2; i <= n; i ++) {
    // 确定状态转移方程
    dp[i] = dp[i-1] + dp[i-2]
  }
  return dp[n]
}
```

### 动态规划-状态压缩 

在动态规划算法中，有一种常见的优化方法叫做**状态压缩，**可以将存储空间从一个数组优化为一个常数。

- 可以发现，对于斐波那契数列求值的时候只需要保存前两个状态的值便可以计算出来，所以只需要使用两个变量来保存这两个状态的值即可。
- 这样就可以减少存储空间的使用**优化了空间复杂度**

```typescript
function fib(n: number): number {
  if (n <= 1) {
    return n
  }

  let pre = 0
  let cur = 1

  for(let i = 2; i <= n; i ++) {
    const next = pre + cur
    pre = cur
    cur = next
  }
  return cur
}
```



需要注意的是，对于斐波那契数列来说，求一个数只需要依赖前两个状态，所以可以通过状态压缩的方式来优化。在其他动态规划场景中，某一个状态的结果不一定依赖哪个状态，这种就不适合使用状态压缩来优化了。