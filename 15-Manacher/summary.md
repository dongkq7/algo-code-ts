Manacher 算法（中文名常译为 “马拉车算法”）是一种专门用于 **高效查找字符串中最长回文子串** 的算法。它的核心优势是通过巧妙的预处理和对称信息利用，将传统解法中 O (n²) 的时间复杂度优化到 **O(n)**（线性时间），尤其适用于处理长字符串场景。

【问题描述】字符串str中，最长回文字串的长度如何求解？

## 预处理

由于偶数个字符与奇数个字符的回文字符串的对称轴不同，不好去处理，所以Manacher算法将字符串统一在字符串每个字符间插入特殊符号（如 `#`），统一奇 / 偶长度回文的处理。

- 比如abc -> `#a#b#c#`



## 加速过程

比如字符串a121b，经过预处理后变成`#a#1#2#1#b#`,以2为中心向左右两边扩，回文区域是`#1#2#1#`，那么：

- 最大回文直径是7
- 最大回文半径是4（2#1#）

1. 对整个字符串遍历，从左向右把每个位置的回文半径进行统计，放入到一个数组中，就组成了一个回文半径数组。
2. 统计统计的信息中，最大最右回文右边界R在哪

- 初始状态是-1
- 在每个字符向左右两边扩，如果右边界变得更大了，就去更新这个变量

1. 统计取得最远边界时的中心点C的位置，如下图

![img](https://cdn.nlark.com/yuque/0/2025/png/22253064/1753678556151-d0ecac4c-c32d-4aeb-8cab-e11b0b6fd1a1.png)

1. 统计接下来的字符情况的时候，由于接下来的字符在R内，则存在如下的状态：

- i在R内，则C一定在i的左侧
- i存在一个与其对应的i'在C的左侧

![img](https://cdn.nlark.com/yuque/0/2025/png/22253064/1753678896215-eae9ab5f-237c-4266-8a77-5f1cfd202d7c.png)

1. 那么此时i'会有如下的情况

5.1 情况一，以i'为中心的回文区域在[L,R]的内部，如下图，那么必存在一段以i为中心的回文区域且与i'为中心的回文区域相等：

![img](https://cdn.nlark.com/yuque/0/2025/png/22253064/1753679380818-42754a07-3968-49ef-bcc3-28c066db1290.png)

为什么i为中心的回文区域不可能超过i'呢？假设i'回文区域的前一个字符是X，后一个字符是Y；i回文区域的前一个字符是Z后一个字符是M，那么存在如下的关系：

![img](https://cdn.nlark.com/yuque/0/2025/png/22253064/1753679552247-2c897d64-419e-4d23-ae8e-1ea12dd4a24e.png)



- i'回文区域是固定的，所以X≠Y，如果相等，那么i'回文区域会更大。又由于Y与Z是关于C对称的且在C为中心的回文字符串里，所以Y=Z。因为X与M也是关于C对称的，所以X=M。又因为X≠Y，所以Z≠M。所以i区域的回文串长度不可能比i'的更大。



5.2 情况二，i’的回文区域有一部分跑到了L..R的外部如下图，此时以i为中心的回文区域的回文半径为R-i

- 为什么i的回文区域不可能超过这个范围呢？取i'回文区域与i回文区域相同的这段来看，假设前一个字符为X，后一个字符为Y。i区域的前一个字符为Z，后一个字符为M。由于X与Y是以i'为中心对称的两个字符，所以X=Y；又由于Y与Z是与C为中心对称的两个字符，所以Y=Z；又因为X≠M，所以Z≠M，所以i的回文范围只能是这么大。



![img](https://cdn.nlark.com/yuque/0/2025/png/22253064/1753681167020-22f939ed-1cc1-4e97-a463-6f872faaf375.png)

5.3 情况三，以i'为中心的回文区域的左侧与L重合，如下图，那么以i为中心的回文区域有一段是不用验证的，就是和i'同范围的这段。i的回文区域有没有可能更大是不确定的，问号处的字符如果与k相同，那么会更大；如果不同那么就不会更大了。所以此时有个加速的过程，有一段区域是不用验证的。

![img](https://cdn.nlark.com/yuque/0/2025/png/22253064/1753681764197-8314f148-891a-4885-ba70-9242d0edd44a.png)

**综上，i'的回文区域知道后，i的回文区域的半径至少对应的是R-i这一段，然后从至少不用验证的区域往外验证即可。**

## 代码实现

```typescript
function manacherString(s: string): string[] {
  const chars = s.split('')
  const res = new Array(2 * chars.length + 1)
  let index = 0
  for (let i = 0; i < res.length; i++) {
    res[i] = (i & 1) === 0 ? '#' : chars[index++]
  }
  return res
}

function palindromeLength(s: string): number {
  if (!s.length) return 0
  // 对字符串进行预处理，121 -> [#,1,#,2,#,1,#]
  const chars = manacherString(s)
  const pArr = new Array(chars.length) // 回文半径数组
  let R = -1 // 回文有边界
  let C = -1 // 回文中心点
  let max = Number.MIN_SAFE_INTEGER

  for (let i = 0; i < chars.length; i++) {
    // 如果R在i外，那么至少有i'对应的回文半径或者R-i对应的区域不用验证
    // 如果R在i内，那么至少当前这个字符所对应的回文半径1不用验证
    pArr[i] = R > i ? Math.min(pArr[2 * C - i], R - i) : 1
    // 尝试向两边扩
    while (i + pArr[i] < chars.length && i - pArr[i] > -1) {
      if (chars[i + pArr[i]] === chars[i - pArr[i]]) {
        pArr[i]++
      } else {
        break
      }
    }
    // 扩不动了看看需不需要更新R
    if (i + pArr[i] > R) {
      R = i + pArr[i]
      C = i
    }
    max = Math.max(max, pArr[i])
  }
  // 原始回文字符串长度 = max - 1
  // 比如#1#2#1#，以2为中心的回文半径为4，原始字符串回文长度为3
  return max - 1
}

console.log(palindromeLength('abccccdd'))
```



## 补充

在一个 `for` 循环中，`(i & 1) == 0` 是用来判断变量 `i` 是否为 偶数 的。

二进制中，偶数的最后一位一定是 0，奇数的最后一位一定是 1（如 `2 → 10`，`3 → 11`，`4 → 100` 等）。

`&` 是按位与运算，`i & 1` 的作用是 取出 `i` 二进制的最后一位：

- 若 `i` 是偶数，最后一位为 0，`i & 1` 的结果为 `0`，因此 `(i & 1) == 0` 成立。
- 若 `i` 是奇数，最后一位为 1，`i & 1` 的结果为 `1`，因此 `(i & 1) == 0` 不成立。